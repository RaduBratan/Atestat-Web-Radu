<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atestat Bratan Radu-George</title>
    <link rel="stylesheet" type="text/css" href="chapters-css/chapters-style.css" media="screen" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.3/TweenMax.min.js"></script>
    <script src="https://unpkg.co/gsap@3/dist/gsap.min.js"></script>

    <script src="https://www.gstatic.com/firebasejs/8.6.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.6.1/firebase-analytics.js"></script>

</head>

<body>
    <article class="chapter-article">
        <header></header>
        <footer></footer>

        <aside class="chapter-menu">
            <span class="chapter-title">Algoritmi</span>
            <div class="chapter-link-container">
                <a class="chapter-link" href="#subchapter1">1. Ce este algoritmul</a>
                <a class="chapter-link" href="#subchapter2">2. Ce face algoritmul</a>
                <a class="chapter-link" href="#subchapter3">3. Clasificare după implementare</a>
                <a class="chapter-link" href="#subchapter4">4. Clasificare după paradigmă</a>
            </div>
            <button class="chapter-button"></button>
        </aside>

        <div class="chapter-content" id="luxy">
            <h3 id="subchapter1">Ce este algoritmul</h3>

            <p>
                Algoritmul este un concept folosit pentru a desemna o mulţime finită de operaţii, complet ordonată în
                timp,
                care pornind de la date de intrare produce într-un timp finit date de ieşire. Cu alte cuvinte,
                algoritmul
                redă metoda de rezolvare a unei probleme într-un număr finit de paşi.
                <br />
                <br />
                Altfel spus, un algoritm este un sistem de reguli care utilizând un set de date iniţiale ale unei
                probleme,
                după execuţia unui număr finit de paşi, facilitează obţinerea datelor finale, trecând printr-un şir de
                rezultate intermediare.

            </p>

            <h3 id="subchapter2">Ce face algoritmul</h3>

            <p>
                Un algoritm trebuie să satisfacă în general următoarele cerinţe:
                <br />
                • claritate – descrierea algoritmului trebuie să se facă precis, fără nimic arbitrar, fără ambiguităţi
                şi să fie
                prevăzute toate etapele de calcul şi toate situaţiile care se pot ivi până la obţinerea soluţiei;
                <br />
                • generalitate – algoritmul trebuie să permită rezolvarea de probleme dintr-o întreagă clasă;
                <br />
                • finititudine – algoritmul trebuie să furnizeze rezultatele într-un număr finit (cât mai mic) de paşi;
                <br />
                • unicitate – etapele algoritmului trebuie să fie definite în mod unic.
            </p>

            <h3 id="subchapter3">Clasificare după implementare</h3>

            <p>
                În funcție de modul de implementare, un algoritm poate fi:
                <br />
                • recursiv – se impelementează prin functii care in corpul lor au secvențe de autoapelare, algoritmul
                este
                efectiv din punctul de vedere a mărimii codului scris, dar partea negativă a acestuia este consumul mare
                de
                memorie pentru parametrii si variabilelor functiilor in cazurile unor recursii ”adînci”;
                <br />
                • iterativ (repetitiv) – se implementeză folosind bucle pentru repetarea operațiilor cu condiții clare
                de
                oprire a buclei, este mai efectiv ca algoritmul recursiv din punctul de vedere a consmului de memorie
                (functiile la fiecare apel stochează în memorie parametri, variabile locale, adresa de revenire);
                <br />
                • serial sau paralel – aceste două tipuri se deosebesc cardinal unul fața de altul, primul se refera la
                proiectarea algoritmului pentru sisteme cu un singur procesor, al doilea se refera la proiectarea unui
                algoritm pentru sisteme cu mai multe procesare, în generl un algoritm serial poate fi transformat în
                unul
                paralel însa nu tottimpul. O analogie exemplificativă: o femeie naște un copil în decursul a nouă luni,
                dar
                nouă femei nu pot naște un copil în decurs de o lună.

            </p>

            <h3 id="subchapter4">Clasificare după paradigmă</h3>

            <p>
                În funcție de paradigma utilizată, ei pot fi:
                <br />
                • algoritmi backtracking – este un algoritm general de descoperire a tuturor soluțiilor unei probleme de
                calcul, algoritm ce se bazează pe construirea incrementală de soluții-candidat, abandonând fiecare
                candidat
                parțial imediat ce devine clar că acesta nu are șanse să devină o soluție validă;
                <br />
                • algoritmi de tip divide et impera – se bazează pe principiul descompunerii problemei în două sau mai
                multe
                subprobleme (mai ușoare), care se rezolvă, iar soluția pentru problema inițială se obține combinând
                soluțiile subproblemelor. De multe ori, subproblemele sunt de același tip și pentru fiecare din ele se
                poate
                aplica aceeași tactică a descompunerii în (alte) subprobleme, până când (în urma descompunerilor
                repetate)
                se ajunge la probleme care admit rezolvare imediată;
                <br />
                • algoritmi de programare dinamică – se aplică atunci cînd rezolvarea unei probleme se reduce la
                rezolvarea
                problemelor ce compun problema principală, astfel combinînd solutii pentru subprobleme mici se obțin
                soluții
                pentru subprobleme mari. Acest algoritm se deosebește de algoritmul devide et impera prin faptul că
                devide
                et impera se aplică problemelor ce se descompun în subprobleme independente pe cînd programarea dinamică
                se
                aplică problemelor ce se descompun în subprobleme soluțiile cărora depind una de alta;
                <br />
                • algoritmi de tip greedy – acest algoritm rezolva problema gasind solutii optime locale cu speranta de
                a
                gasi solutia optima globala.
            </p>
        </div>
    </article>

    <script type="text/javascript" src="chapters-js/chapters-logic.js"></script>
</body>

</html>